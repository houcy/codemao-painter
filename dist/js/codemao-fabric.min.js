/**
 * Created by greendou on 16/4/9.
 * Renderer of Cursor (Mostly for Pencil&Eraser)
 */

(function () {
    if(!fabric){
        return;
    }

    function CursorRenderer (canvas, brush, options) {
        "use strict";
        this.canvas = canvas;
        this.brush = brush;
        this.ctx = canvas.getContext('2d');

        if(options) {
            this.width = options.width || 1;
            this.color = options.color || 'black';
        }else{
            this.width = 1;
            this.color = 'black';
        }
    }

    CursorRenderer.prototype.prepareForRender = function() {
        "use strict";
        var ctx = this.ctx;
        ctx.lineWidth = this.width;
        ctx.strokeStyle = this.color;
    };

    CursorRenderer.prototype.renderCircle = function (x, y) {
        var ctx = this.ctx,
            width = this.brush.width;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.arc(x,y,width / 2,0,Math.PI*2,true);
        ctx.stroke();
        ctx.fill();
        //ctx.beginPath();
        //ctx.moveTo(width / 2 , 0);
        //ctx.lineTo(width / 2, width);
    };

    CursorRenderer.prototype.renderPoint = function (x, y) {
        var ctx = this.ctx;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'black';
        for(var i = 0;i < 20;i=i+2) {
            ctx.beginPath();
            ctx.arc(x,y,20,Math.PI*2 * i/20,Math.PI*2 * (i+1)/20,false);
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(x,y,20,0,Math.PI*2,true);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x,y-1);
        ctx.lineTo(x,y+1);
        ctx.stroke();
        ctx.moveTo(x-1,y);
        ctx.lineTo(x+1,y);
        ctx.stroke();

        //ctx.fill();
        //ctx.beginPath();
        //ctx.moveTo(width / 2 , 0);
        //ctx.lineTo(width / 2, width);
    };

    fabric.CursorRenderer = CursorRenderer;
})();

/**
 * Created by GreenDou on 16/4/9.
 * Eraser Brush
 */

(function() {

    /**
     * EraserBrush class
     * @class fabric.EraserBrush
     * @extends fabric.BaseBrush
     */
    fabric.EraserBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

        /**
         * Constructor
         * @param {fabric.Canvas} canvas
         * @param options
         * @return {fabric.PencilBrush} Instance of a pencil brush
         */
        initialize: function(canvas , options) {
            this.canvas = canvas;
            this.backupCanvasEl = this.canvas._createCanvasElement();
            this.backupContext = this.backupCanvasEl.getContext('2d');
            this.canvas._copyCanvasStyle(this.canvas.upperCanvasEl, this.backupCanvasEl);
            this.canvas._applyCanvasStyle(this.backupCanvasEl);
            this.canvas.freeDrawingCursor = 'none';
            this._points = [ ];
            this.width = 10;
            //init options

            //Dynamic events
            //this.onMouseOut = this.onMouseOut.bind(this);
            //this.events = {
            //    mouseout: this.canvas._onMouseOut
            //};

            for (var prop in options) {
                if(options.hasOwnProperty(prop)) {
                    this[prop] = options[prop];
                }
            }

            this.cursorRenderer = new fabric.CursorRenderer(this.canvas.cursorCanvasEl, this);
        },

        /**
         * Inovoked on mouse down
         * @param {Object} pointer
         */
        onMouseDown: function(pointer) {
            this._prepareForDrawing(pointer);
            // capture coordinates immediately
            // this allows to draw dots (when movement never occurs)
            this._captureDrawingPath(pointer);
            this._render();
        },

        /**
         * Inovoked on mouse move
         * @param {Object} pointer
         */
        onMouseMove: function(pointer) {
            this._captureDrawingPath(pointer);
            // redraw curve
            // clear top canvas
            this.canvas.clearContext(this.canvas.contextTop);
            this._render();
        },

        /**
         * Invoked on mouse up
         */
        onMouseUp: function() {
            this._finalizeAndAddPath();
        },

        onMouseOut: function (options) {
            this.canvas.clearContext(this.canvas.contextCursor);
        },

        /**
         * @private
         * @param {Object} pointer Actual mouse position related to the canvas.
         */
        _prepareForDrawing: function(pointer) {

            var p = new fabric.Point(pointer.x, pointer.y);

            this._reset();
            this._addPoint(p);

            this.canvas.clearContext(this.backupCanvasEl.getContext('2d'));
            this.backupContext.drawImage(this.canvas.lowerCanvasEl,0,0);
            this.canvas.clearContext(this.canvas.contextContainer);
            this.canvas.contextTop.moveTo(p.x, p.y);

            this.cursorRenderer.prepareForRender();
        },

        /**
         * @private
         * @param {fabric.Point} point Point to be added to points array
         */
        _addPoint: function(point) {
            this._points.push(point);
        },

        /**
         * Clear points array and set contextTop canvas style.
         * @private
         */
        _reset: function() {
            this._points.length = 0;

            this._setBrushStyles();
            this._setShadow();
        },

        _setBrushStyles: function() {
            "use strict";
            var ctx = this.canvas.contextTop;
            ctx.lineWidth = this.width;
            ctx.lineCap = this.strokeLineCap;
            ctx.lineJoin = this.strokeLineJoin;
            if (this.strokeDashArray && fabric.StaticCanvas.supports("setLineDash")) {
                ctx.setLineDash(this.strokeDashArray);
            }
        },

        /**
         * @private
         * @param {Object} pointer Actual mouse position related to the canvas.
         */
        _captureDrawingPath: function(pointer) {
            var pointerPoint = new fabric.Point(pointer.x, pointer.y);
            this._addPoint(pointerPoint);
        },

        /**
         * Draw a smooth path on the topCanvas using quadraticCurveTo
         * @private
         */
        _render: function() {
            var ctx  = this.canvas.contextTop,
                v = this.canvas.viewportTransform,
                p1 = this._points[0],
                p2 = this._points[1];

            ctx.save();
            ctx.drawImage(this.backupCanvasEl,0,0);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
            ctx.beginPath();

            //if we only have 2 points in the path and they are the same
            //it means that the user only clicked the canvas without moving the mouse
            //then we should be drawing a dot. A path isn't drawn between two identical dots
            //that's why we set them apart a bit
            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
                p1.x -= 0.5;
                p2.x += 0.5;
            }
            ctx.moveTo(p1.x, p1.y);

            for (var i = 1, len = this._points.length; i < len; i++) {
                // we pick the point between pi + 1 & pi + 2 as the
                // end point and p1 as our control point.
                var midPoint = p1.midPointFrom(p2);
                ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);

                p1 = this._points[i];
                p2 = this._points[i + 1];
            }
            // Draw last line as a straight line while
            // we wait for the next point to be able to calculate
            // the bezier control point
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
            ctx.restore();
        },

        /**
         * Converts points to SVG path
         * @param {Array} points Array of points
         * @param {Number} minX
         * @param {Number} minY
         * @return {String} SVG path
         */
        convertPointsToSVGPath: function(points) {
            var path = [],
                p1 = new fabric.Point(points[0].x, points[0].y),
                p2 = new fabric.Point(points[1].x, points[1].y);

            path.push('M ', points[0].x, ' ', points[0].y, ' ');
            for (var i = 1, len = points.length; i < len; i++) {
                var midPoint = p1.midPointFrom(p2);
                // p1 is our bezier control point
                // midpoint is our endpoint
                // start point is p(i-1) value.
                path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
                p1 = new fabric.Point(points[i].x, points[i].y);
                if ((i + 1) < points.length) {
                    p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);
                }
            }
            path.push('L ', p1.x, ' ', p1.y, ' ');
            return path;
        },

        /**
         * Creates fabric.Path object to add on canvas
         * @param {String} pathData Path data
         * @return {fabric.Path} Path to add on canvas
         */
        createPath: function(pathData) {
            var path = new fabric.Path(pathData, {
                fill: null,
                stroke: this.color,
                strokeWidth: this.width,
                strokeLineCap: this.strokeLineCap,
                strokeLineJoin: this.strokeLineJoin,
                strokeDashArray: this.strokeDashArray,
                originX: 'center',
                originY: 'center'
            });

            if (this.shadow) {
                this.shadow.affectStroke = true;
                path.setShadow(this.shadow);
            }

            return path;
        },

        /**
         * On mouseup after drawing the path on contextTop canvas
         * we use the points captured to create an new fabric path object
         * and add it to the fabric canvas.
         */
        _finalizeAndAddPath: function() {
            var ctx = this.canvas.contextTop,
                data, trimData, layerObject,
                myself = this,
                currentLayer = this.canvas.layerManager.currentLayer;
            ctx.closePath();
            trimData = trimCanvasWithPosition(this.canvas.upperCanvasEl);
            data = trimData.canvas.toDataURL('png');
            //img=document.createElement('img');
            //img.setAttribute('src',data);
            //layerObject = new fabric.Image(img, {
            //    left: 0,
            //    top: 0,
            //    angle: 0,
            //    opacity: 1
            //}).setCoords();

            fabric.Image.fromURL(data, function(image) {
                image.set({
                    left: trimData.left,
                    top:  trimData.top,
                    angle: 0
                })
                    .scale(1)
                    .setCoords();
                Painter.canvas.add(image);
                myself.canvas.clearContext(myself.canvas.contextTop);
                currentLayer.objects.splice(0,currentLayer.objects.length,image);
                myself.canvas.renderAll();
            });




            //var pathData = this.convertPointsToSVGPath(this._points).join('');
            //if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
            //    // do not create 0 width/height paths, as they are
            //    // rendered inconsistently across browsers
            //    // Firefox 4, for example, renders a dot,
            //    // whereas Chrome 10 renders nothing
            //    this.canvas.renderAll();
            //    return;
            //}
            //
            //var path = this.createPath(pathData);
            //
            //this.canvas.add(path);
            //path.setCoords();
            //
            //this.canvas.clearContext(this.canvas.contextTop);
            //this._resetShadow();
            //this.canvas.renderAll();
            //
            //// fire event 'path' created
            //this.canvas.fire('path:created', { path: path });
        },

        cursorRender : function (pointer) {
            this.canvas.clearContext(this.canvas.contextCursor);
            this.cursorRenderer.renderCircle(pointer.x, pointer.y);
            //this.canvas.contextTop.drawImage(this.canvas.cursorCanvasEl,0,0);
        }
    });
})();

/**
 * Created by GreenDou on 16/4/7.
 * LayerManager Class
 */

(function(fabric){
    "use strict";

    if(!fabric){
        return;
    }

    function LayerManager(parentCanvas) {
        this.layerList = [];
        this.currentLayer = null;
        this.parentCanvas = parentCanvas;

        if(parentCanvas){
            this.currentLayer = new fabric.Layer(parentCanvas.lowerCanvasEl);
            this.currentLayer.objects = parentCanvas._objects;
            this.addLayer(this.currentLayer);
        }
    }

    LayerManager.prototype.addLayer = function (layer){
        var upperCanvasEl = this.parentCanvas.upperCanvasEl;

        if(!layer){
            var canvasEl = this.parentCanvas._createCanvasElement();
            layer = new fabric.Layer(canvasEl);
        } else if (!layer.canvasEl) {
            layer.canvasEl = new this.parentCanvas._createCanvasElement();
        }
        this.layerList.push(layer);
        layer.parent = this;
        this.parentCanvas.wrapperEl.insertBefore(layer.canvasEl, upperCanvasEl);

        this.parentCanvas._copyCanvasStyle(upperCanvasEl, layer.canvasEl);
        this.parentCanvas._applyCanvasStyle(layer.canvasEl);

        this.selectLayer(this.layerList.length - 1);
    };

    /**
     * Remove Layer
     * @param index
     */
    LayerManager.prototype.removeLayer = function (index) {
        if(index < this.layerList.length && this.layerList.length > 1){
            if(this.layerList[index] === this.currentLayer){
                if(index === 0){
                    this.selectLayer(1);
                }else{
                    this.selectLayer(index - 1);
                }
            }
            this.parentCanvas.wrapperEl.removeChild(this.layerList[index].canvasEl);
            this.layerList.splice(index,1);
        }
    };

    LayerManager.prototype.upLayer = function (index) {
        if(index!== this.layerList.length - 1){
            this.moveLayer(index + 1, index);
        }
    };

    /**
     * Move Layer
     * @param dest Index
     * @param src  Index
     */
    LayerManager.prototype.moveLayer = function (dest, src) {
        if(dest == src) {
            return;
        }
        if(dest === this.layerList.length - 1){
            this.parentCanvas.wrapperEl.insertBefore(this.layerList[src].canvasEl, this.parentCanvas.upperCanvasEl);
        }else{
            this.parentCanvas.wrapperEl.insertBefore(this.layerList[src].canvasEl, this.layerList[dest].canvasEl);
        }
        this.layerList.splice(dest, 0, this.layerList[src]);
        if(dest > src){
            this.layerList.splice(src,1);
        }else{
            this.layerList.splice(src + 1,1);
        }
    };

    LayerManager.prototype.downLayer = function (index){
        if(index !== 0){
            this.moveLayer(index - 1, index);
        }
    };

    LayerManager.prototype.showLayer = function (index) {
        if(index< this.layerList.length){
            this.layerList[index].canvasEl.style.display = null;
            for(var i = 0; i < this.layerList[index].objects.length; ++i){
                this.layerList[index].objects[i].visible = true;
            }
            this.layerList[index].visible = true;
            this.parentCanvas.renderAll();
        }
    };

    LayerManager.prototype.hideLayer = function (index) {
        if(index < this.layerList.length){
            this.layerList[index].canvasEl.style.display = 'none';
            for(var i = 0; i < this.layerList[index].objects.length; ++i){
                this.layerList[index].objects[i].visible = false;
            }
            this.layerList[index].visible = false;
            this.parentCanvas.renderAll();
            //todo: will cause error in trim-canvas for width is 0
        }
    };

    LayerManager.prototype.toggleLayerVisible = function (index) {
        if(this.layerList[index].visible) {
            this.hideLayer(index);
        } else {
            this.showLayer(index);
        }
    };
    /**
     * Select Layer
     * @param index
     */
    LayerManager.prototype.selectLayer = function (index) {
        if(index < this.layerList.length) {
            this.parentCanvas.deactivateAllWithDispatch();
            this.parentCanvas.renderAll();
            this.currentLayer = this.layerList[index];
            this.parentCanvas.lowerCanvasEl = this.currentLayer.canvasEl;
            this.parentCanvas.contextContainer = this.currentLayer.canvasEl.getContext('2d');
            this.parentCanvas._objects = this.currentLayer.objects;
        }
    };

    /**
     *  Reset layers
     */
    LayerManager.prototype.clearLayers = function () {
        this.selectLayer(0);
        this.showLayer(0);
        while(this.layerList.length > 1) {
            this.removeLayer(1);
        }
    };

    /**
     * Make everything into one layer and kill others
     */
    LayerManager.prototype.combineAllLayers = function () {
        this.selectLayer(0);
        while(this.layerList.length > 1) {
            this.currentLayer.objects = this.currentLayer.objects.concat(this.layerList[1].objects);
            this.parentCanvas._objects = this.currentLayer.objects;
            this.removeLayer(1);
        }
    };

    /**
     * Combine layers
     * @param layers:Array<Number> index of layers
     */
    LayerManager.prototype.combineLayers = function (layers) {
        this.selectLayer(layers[0]);
        while(layers.length > 1) {
            if(layers[1] < this.layerList.length){
                this.currentLayer.objects = this.currentLayer.objects.concat(this.layerList[layers[1]].objects);
                this.parentCanvas._objects = this.currentLayer.objects;
                this.removeLayer(layers[1]);
            }
        }
    };

    fabric.LayerManager = LayerManager;
})(fabric);

/**
 * Created by GreenDou on 16/4/7.
 * Layer Class
 */

(function (fabric) {
    "use strict";

    if(!fabric){
        return;
    }

    function Layer (canvasEl, name) {
        this.canvasEl = canvasEl;
        this.name = name || '新建图层' + Layer.prototype.count++;
        this.parent = null;
        this.objects = [];
        //Use show&hideLayer to set this value,otherwise it won't work
        this.visible = true;
    }

    Layer.prototype.count = 1;

    Layer.prototype.resetCount = function () {
        this.prototype.count = 1;
    };

    fabric.Layer = Layer;
})(fabric);
!function () {
    'use strict';
    window.Painter = {

        init: function (width, height) {
            var $painterContent = $('.painter-content'),
                $painterCanvas = $('#painter-canvas'),
                $painterContainer = $('#painter-container'),
                myself = this;

            this.$painterContent = $painterContent;
            this.$btnPencil = $('.btn-pencil');
            this.$btnPointer = $('.btn-pointer');

            if (!width) {
                width = $painterContent.width() - $('.painter-left-buttons').width() - $('.painter-right-buttons').width() - 46;
                height = $painterContent.height() - $('.painter-properties').height() - 46;
            }
            this.width = width;
            this.height = height;
            $painterCanvas.attr('height', height);
            $painterCanvas.attr('width', width);
            var canvas = new fabric.Canvas('painter-canvas');
            Painter.canvas = canvas;

            $painterContainer.css('visibility', 'visible');
            $painterContainer.hide();

            //init vue

            this.vm = new Vue({
                el: '#painter-container',
                data: {
                    width: 10,
                    content: '添加文字后在这里修改',
                    type: 'object',
                    color: ''
                },
                watch: {
                    'content': function (value) {
                        var object = canvas.getActiveObject();
                        if (!object) return;

                        object.set('text', value).setCoords();
                        canvas.renderAll();
                    },
                    'width': function (value) {
                        var styleName = 'strokeWidth';
                        value = parseInt(value, 10);
                        if (canvas.freeDrawingBrush) {
                            canvas.freeDrawingBrush.width = value || 15;
                        }
                        var object = canvas.getActiveObject();
                        if (!object) return;

                        if(this.type === 'text') {
                            styleName = 'fontSize';
                        }
                        if (object.setSelectionStyles && object.isEditing) {
                            var style = { };
                            style[styleName] = value;
                            object.setSelectionStyles(style);
                            object.setCoords();
                        }
                        else {
                            object[styleName] = value;
                        }

                        object.setCoords();
                        canvas.renderAll();
                    },
                    'color': function () {
                        cur_color = this.color;

                        canvas.freeDrawingBrush.color = cur_color;

                        var activeObject = canvas.getActiveObject(),
                            activeGroup = canvas.getActiveGroup();

                        if (activeGroup) {
                            var objectsInGroup = activeGroup.getObjects();
                            canvas.discardActiveGroup();
                            objectsInGroup.forEach(function (activeObject) {
                                if (activeObject.stroke) {
                                    activeObject.setStroke(cur_color);
                                } else {
                                    activeObject.setColor(cur_color);
                                }
                            });
                        }
                        else if (activeObject) {
                            if (activeObject.stroke) {
                                activeObject.setStroke(cur_color);
                            } else {
                                activeObject.setColor(cur_color);
                            }
                        }
                        canvas.renderAll();
                    }
                }
                //methods: {
                //    setContent: function (event) {
                //        this.content = event.target._value;
                //    }
                //}
            });

            canvas.on('object:selected', updateScope);

            function updateScope() {
                var object = canvas.getActiveObject();
                if (!object) return;

                myself.vm.content = object['text'] || '';
                if(myself.vm.content !== '') {
                    myself.vm.type = 'text';
                    myself.vm.width = object['fontSize'];
                }else{
                    myself.vm.type = 'path';
                    if (canvas.freeDrawingBrush) {
                        myself.vm.width = object['strokeWidth'];
                    }
                }
            }


            function getActiveProp(name) {
                var object = canvas.getActiveObject();
                if (!object) return '';

                return object[name] || '';
            }

            ////init colors
            function initColors() {
                //var total = 255 * 255 * 255;
                var colors =  ['e3135c', 'cd0024', 'f1521e', 'fce932','f5a72e', '8b5430', 'bd0add',
                    '9016e8', '4b90e0', '437715', '85d036', 'bae98a', '000000', 'ffffff']
                //for (var i = 0; i < total - 100; i += total / 40) {
                //    i = parseInt(i);
                //    var color = i.toString(16);
                //    while (color.length < 6) {
                //        color = '0' + color;
                //    }
                //    $('.painter-colors-wrap').append(template('template-colors', {color: '#' + color}));
                //}
                for (var i = 0; i < colors.length; ++i){
                    $('.painter-colors-wrap').append(template('template-colors', {color: '#' + colors[i]}));
                }

            }

            var cur_color = '';
            initColors();

            $('.painter-btn').on('click', function () {
                if (!$(this).hasClass('active')) {
                    $(this).parent().find('.painter-btn').removeClass('active');
                    $(this).addClass('active');
                    if ($(this).hasClass('painter-colors')) {
                        canvas.freeDrawingBrush.color = $(this).attr('data-value');
                        cur_color = $(this).attr('data-value');
                        myself.vm.color = cur_color;

                        var activeObject = canvas.getActiveObject(),
                            activeGroup = canvas.getActiveGroup();

                        if (activeGroup) {
                            var objectsInGroup = activeGroup.getObjects();
                            canvas.discardActiveGroup();
                            objectsInGroup.forEach(function (activeObject) {
                                if (activeObject.stroke) {
                                    activeObject.setStroke(cur_color);
                                } else {
                                    activeObject.setColor(cur_color);
                                }
                            });
                        }
                        else if (activeObject) {
                            if (activeObject.stroke) {
                                activeObject.setStroke(cur_color);
                            } else {
                                activeObject.setColor(cur_color);
                            }
                        }
                        canvas.renderAll();
                    }
                }
            });
            function addRect(width, height, x, y) {
                var rect = new fabric.Rect({
                    top: y,
                    left: x,
                    width: width,
                    height: height,
                    fill: canvas.freeDrawingBrush.color
                });
                canvas.add(rect);
            }

            function addCircle(radius, x, y) {
                canvas.add(new fabric.Circle({
                    left: x,
                    top: y,
                    fill: canvas.freeDrawingBrush.color,
                    radius: 50
                    //opacity: 0.8
                }));
            }

            function addTriangle(width, height, x, y) {
                canvas.add(new fabric.Triangle({
                    left: x,
                    top: y,
                    fill: canvas.freeDrawingBrush.color,
                    width: width,
                    height: height
                }));
            }

            function addImage(path, x, y, scale) {
                fabric.Image.fromURL(path, function (image) {
                    image.set({
                        left: x || 0,
                        top: y || 0,
                        angle: 0
                    })
                        .scale(1)
                        .setCoords();
                    Painter.canvas.add(image);
                    Painter.canvas.renderAll();
                });
            }

            Painter.addImage = addImage;

            function addText(x, y) {
                "use strict";
                var text = '点我选中文字，在画布下方可以修改文字内容和样式哦~';

                var textSample = new fabric.Text(text, {
                    left: x || canvas.getWidth() / 2,
                    top: y || canvas.getHeight() / 2,
                    fontFamily: 'Microsoft YaHei',
                    angle: 0,
                    fill: canvas.freeDrawingBrush.color,
                    scaleX: 1,
                    scaleY: 1,
                    fontWeight: '',
                    originX: 'left',
                    hasRotatingPoint: true,
                    centerTransform: true
                });

                Painter.canvas.add(textSample);
            }

            function removeSelected() {
                var activeObject = canvas.getActiveObject(),
                    activeGroup = canvas.getActiveGroup();

                if (activeGroup) {
                    var objectsInGroup = activeGroup.getObjects();
                    canvas.discardActiveGroup();
                    objectsInGroup.forEach(function (object) {
                        canvas.remove(object);
                    });
                }
                else if (activeObject) {
                    canvas.remove(activeObject);
                }
            }

            function initEvents() {
                var $btnPencil = myself.$btnPencil,
                    $btnEraser = $('.btn-eraser'),
                    $btnRotation = $('.btn-rotation');
                $('.painter-colors:first-child').click();
                $btnPencil.on('click', function () {
                    canvas.setFreeDrawingBrush('pencil', {
                        width: 15,
                        color: cur_color
                    });
                    canvas.setDrawingMode(true);
                    myself.vm.width = 15;
                    //canvas.freeDrawingBrush.width=10;
                    //canvas.freeDrawingBrush.color=cur_color;
                });
                $btnEraser.on('click', function () {
                    canvas.setFreeDrawingBrush('eraser', {
                        width: 15,
                        color: cur_color
                    });
                    canvas.setDrawingMode(true);
                });
                $btnRotation.on('click', function () {
                    canvas.setDrawingMode(true);
                    canvas.setFreeDrawingBrush('rotation', {});
                });
                $('.btn-circle').on('click', function () {
                    myself.$btnPointer.click();
                    addCircle(100, 100, 100);

                });
                $('.btn-rect').on('click', function () {
                    myself.$btnPointer.click();
                    addRect(100, 100, 100, 100);
                });
                $('.btn-triangle').on('click', function () {
                    myself.$btnPointer.click();
                    addTriangle(100, 100, 100, 100);
                });
                $('.btn-text').on('click', function () {
                    myself.$btnPointer.click();
                    addText(0,0);
                });

                $btnPencil .click();
                $('.painter-btn-remove').on('click', removeSelected);
                myself.$btnPointer.on('click', function () {
                    canvas.setDrawingMode(false);
                });
                $('.painter-btn-close').on('click', function () {
                    canvas.setDrawingMode(false);
                    $('#painter-container').hide();
                });
                $('.painter-btn-check').on('click', function () {
                    var result, data, param = {};
                    //todo: Deal with the End
                    //canvas.contextContainer.imageSmoothingEnabled = false;
                    canvas.setDrawingMode(false);
                    //result = toBase64();
                    canvas.layerManager.combineAllLayers();
                    var activeObj = Painter.canvas.getActiveObject();
                    var activeGroup = canvas.getActiveGroup();
                    if (activeGroup) {
                        var objectsInGroup = activeGroup.getObjects();
                        canvas.discardActiveGroup();
                        objectsInGroup.forEach(function (object) {
                            object.active = false;
                        });
                    }
                    if (activeObj) {
                        activeObj.active = false;
                    }
                    canvas.renderAll();
                    canvas.setZoom(1);
                    //options.anchorOffsetX = result.rc.x;
                    //options.anchorOffsetY = result.rc.y;

                    param.img = canvas.lowerCanvasEl;
                    param.rc = canvas.rotationPoint;
                    param.name = $('.painter-name').val();

                    if(canvas.callback){
                        canvas.callback(param);
                    }

                    $('#painter-container').hide();
                });
            }

            initEvents();

            function toBase64() {
                var result;

                canvas.layerManager.combineAllLayers();
                var activeObj = Painter.canvas.getActiveObject();
                var activeGroup = canvas.getActiveGroup();
                if (activeGroup) {
                    var objectsInGroup = activeGroup.getObjects();
                    canvas.discardActiveGroup();
                    objectsInGroup.forEach(function (object) {
                        object.active = false;
                    });
                }
                if (activeObj) {
                    activeObj.active = false;
                }
                Painter.canvas.renderAll();
                Painter.canvas.setZoom(1);
                var data = canvas.toDataURL('png');
                var img = document.createElement('img');
                img.setAttribute('width', width);
                img.setAttribute('height', height);
                img.setAttribute('src', data);
                var c = document.createElement('canvas');
                c.setAttribute('width', width);
                c.setAttribute('height', height);
                var ctx = c.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                canvas.setZoom(1);

                result = trimCanvasWithPosition(c, canvas.rotationPoint);
                return result;
            }
        },

        /**
         * Open image in the canvas
         * @param img
         * @param name
         * @param options
         */
        openIn: function (img, name, options) {
            var width = 0, height = 0;
            if(options) {
                width = options.width;
                height = options.height;
                Painter.canvas.rotationPoint = {
                    x: options.rotationCenter.x + (Painter.canvas.width - width)/ 2,
                    y: options.rotationCenter.y + (Painter.canvas.height - height)/ 2
                };
                Painter.canvas.callback = options.callback;
            }
            Painter.canvas.clear();

            $('.painter-name').val(name);

            Painter.canvas.setHeight(this.height);
            Painter.canvas.setWidth(this.width);
            Painter.canvas.renderAll();
            Painter.addImage(img, (Painter.canvas.width - width)/ 2, (Painter.canvas.height - height)/ 2);

            this.$btnPencil.click();
            $('#painter-container').show();
        },

        destroy: function () {
            $('#painter-container').hide();
        }
    };
}();

/**
 * Created by GreenDou on 16/4/12.
 * Point Brush
 */

(function () {

    /**
     * PointBrush class
     * @class fabric.PointBrush
     * @extends fabric.BaseBrush
     */
    fabric.PointBrush = fabric.util.createClass(fabric.BaseBrush,
        /** @lends fabric.PointBrush.prototype */
        {

            /**
             * Constructor
             * @param {fabric.Canvas} canvas
             * @param {function} callback
             * @param options
             * @return {fabric.PencilBrush} Instance of a pencil brush
             */
            initialize: function (canvas, callback, options) {
                this.canvas = canvas;
                this.callback = callback;
                this.canvas.freeDrawingCursor = 'none';
                this.width = 1;

                for (var prop in options) {
                    if (options.hasOwnProperty(prop)) {
                        this[prop] = options[prop];
                    }
                }
                this.cursorRenderer = new fabric.CursorRenderer(this.canvas.cursorCanvasEl, this);
                this.cursorRenderer.width = this.width;
            },

            /**
             * Inovoked on mouse down
             * @param {Object} pointer
             */
            onMouseDown: function (pointer) {
                this._prepareForDrawing(pointer);
                this.point = pointer;
                // capture coordinates immediately
                // this allows to draw dots (when movement never occurs)
                //this._captureDrawingPath(pointer);
                this._render(pointer);
            },

            /**
             * Inovoked on mouse move
             * @param {Object} pointer
             */
            onMouseMove: function (pointer) {
                //this._captureDrawingPath(pointer);
                // redraw curve
                // clear top canvas
                this.canvas.clearContext(this.canvas.contextTop);
                this.point = pointer;
                this._render(pointer);
            },

            /**
             * Invoked on mouse up
             */
            onMouseUp: function () {
                this._finalizeAndCallback();
            },

            /**
             * @private
             * @param {Object} pointer Actual mouse position related to the canvas.
             */
            _prepareForDrawing: function (pointer) {

                this._reset();
                this.canvas.clearContext(this.canvas.contextTop);
                this.cursorRenderer.prepareForRender();
            },

            /**
             * Clear points array and set contextTop canvas style.
             * @private
             */
            _reset: function () {
                this._setBrushStyles();
                this._setShadow();
            },

            _setBrushStyles: function () {
                "use strict";
                var ctx = this.canvas.contextTop;
                ctx.lineWidth = this.width;
                ctx.lineCap = this.strokeLineCap;
                ctx.lineJoin = this.strokeLineJoin;
                if (this.strokeDashArray && fabric.StaticCanvas.supports("setLineDash")) {
                    ctx.setLineDash(this.strokeDashArray);
                }
            },

            /**
             * Draw a smooth path on the topCanvas using quadraticCurveTo
             * @private
             */
            _render: function (pointer) {
                var ctx = this.canvas.contextTop,
                    v = this.canvas.viewportTransform,
                    x = pointer.x,
                    y = pointer.y;
                ctx.lineWidth = 1;
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, this.canvas.height);
                ctx.stroke();
                ctx.moveTo(0, y);
                ctx.lineTo(this.canvas.width, y);
                ctx.stroke();
            },

            /**
             * On mouseup after drawing the path on contextTop canvas
             * we use the points captured to create an new fabric path object
             * and add it to the fabric canvas.
             */
            _finalizeAndCallback: function () {
                "use strict";
                if (this.callback) {
                    this.callback(this.point);
                }
            },

            cursorRender: function (pointer) {
                this.canvas.clearContext(this.canvas.contextCursor);
                this.cursorRenderer.renderPoint(pointer.x, pointer.y);
                //this.canvas.contextTop.drawImage(this.canvas.cursorCanvasEl,0,0);
            },

            renderPoint: function () {
                "use strict";
                this._render(this.point);
            }


        });
})();

(function () {
    window.trim_canvas = function (c) {
        // open new window with trimmed image:
        return getCanvas(c).canvas;
    };

    /**
     * Trim with Position Info
     * @param c Canvas Context
     * @param {{x:number,y:number}} rc Rotation Center
     * @returns {{canvas: *, left: null, top: null, rc: *}}
     */
    window.trimCanvasWithPosition = function (c, rc) {
        "use strict";
        var result = getCanvas(c, rc);
        if(rc) {
            rc.x = rc.x - result.bound.left;
            rc.y = rc.y - result.bound.top;
        }

        // open new window with trimmed image:
        return {
            canvas: result.canvas,
            left: result.bound.left,
            top: result.bound.top,
            rc: rc
        };
    };

    function detectBounds(c, rc) {
        var ctx = c.getContext('2d'),
            pixels = ctx.getImageData(0, 0, c.width, c.height),
            l = pixels.data.length,
            i,
            bound = {
                top: null,
                left: null,
                right: null,
                bottom: null
            },
            x, y;

        for (i = 0; i < l; i += 4) {
            if (pixels.data[i + 3] !== 0) {
                x = (i / 4) % c.width;
                y = ~~((i / 4) / c.width);

                if (bound.top === null) {
                    bound.top = y;
                }

                if (bound.left === null) {
                    bound.left = x;
                } else if (x < bound.left) {
                    bound.left = x;
                }

                if (bound.right === null) {
                    bound.right = x;
                } else if (bound.right < x) {
                    bound.right = x;
                }

                if (bound.bottom === null) {
                    bound.bottom = y;
                } else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }

        if(rc){
            if (bound.top > rc.y) {
                bound.top = rc.y;
            }
            if (bound.bottom < rc.y) {
                bound.bottom = rc.y;
            }
            if (bound.left > rc.x) {
                bound.left = rc.x;
            }
            if (bound.right < rc.x) {
                bound.right = rc.x;
            }
        }

        return bound;
    }

    function getCanvas (c, rc) {
        "use strict";
        var copy = document.createElement('canvas').getContext('2d');
        var bound = detectBounds(c, rc);
        var trimHeight = bound.bottom - bound.top + 3,
            trimWidth = bound.right - bound.left + 3;

        copy.canvas.width = trimWidth;
        copy.canvas.height = trimHeight;
        copy.drawImage(c, bound.left, bound.top, trimWidth, trimHeight,
            0, 0, trimWidth, trimHeight);
        return {
            canvas: copy.canvas,
            bound: bound
        };
    }

})();
